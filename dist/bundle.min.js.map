{"version":3,"file":"bundle.min.js","sources":["../src/sep.ts","../src/sizing.ts","../src/resizing.ts","../src/main.ts"],"sourcesContent":["import { separator } from \"./types\";\r\n\r\nexport function createSeparators(\r\n  parent: HTMLElement,\r\n  n_children: number,\r\n  mode: \"vertical\" | \"horizontal\"\r\n): Array<separator> {\r\n  const anchor_size = \"20px\";\r\n\r\n  if (n_children === 0) return [];\r\n  const separators: Array<separator> = Array(n_children - 1)\r\n    .fill(\"\")\r\n    .map((_) => {\r\n      const element = createSep(mode, anchor_size);\r\n      const onHighlightCallbacks: Set<Function> = new Set();\r\n      let state: \"idle\" | \"resizing\" | \"silent\" = \"idle\";\r\n      function update(loc: string) {\r\n        if (mode === \"horizontal\") {\r\n          element.style.left = `calc(${loc})`;\r\n        } else {\r\n          element.style.top = `calc(${loc})`;\r\n        }\r\n      }\r\n      function setState(new_state: \"idle\" | \"resizing\" | \"silent\") {\r\n        state = new_state;\r\n      }\r\n      function setHighlight(yes: boolean = true) {\r\n        onHighlightCallbacks.forEach((c) => c(yes));\r\n        element.children[0].classList.toggle(\"sr-separator-highlight\", yes);\r\n      }\r\n      element.addEventListener(\"pointerenter\", () => {\r\n        if (state === \"idle\") setHighlight(true);\r\n      });\r\n      element.addEventListener(\"pointerleave\", () => {\r\n        if (state === \"idle\") setHighlight(false);\r\n      });\r\n      return {\r\n        element,\r\n        position: 0,\r\n        initial_position: 0,\r\n        update,\r\n        setState,\r\n        setHighlight,\r\n        on(event, callback) {\r\n          if (event === \"highlight\") {\r\n            onHighlightCallbacks.add(callback);\r\n          } else {\r\n            console.warn(\r\n              `'${event}' is an unknown event name for a separator. Ignored.`\r\n            );\r\n          }\r\n        },\r\n        off(event, callback = null) {\r\n          if (event === \"highlight\") {\r\n            if (callback === null) {\r\n              onHighlightCallbacks.clear();\r\n            } else {\r\n              onHighlightCallbacks.delete(callback);\r\n            }\r\n          } else {\r\n            console.warn(\r\n              `'${event}' is an unknown event name for a separator. Ignored.`\r\n            );\r\n          }\r\n        },\r\n      };\r\n    });\r\n  separators.forEach((e) => parent.append(e.element));\r\n  return separators;\r\n}\r\n\r\nfunction createSep(\r\n  mode: \"vertical\" | \"horizontal\",\r\n  anchor_size: string\r\n): HTMLElement {\r\n  const sep = document.createElement(\"div\");\r\n  sep.classList.add(\"sr-separator-anchor\");\r\n  sep.style.position = \"absolute\";\r\n  sep.style.display = \"flex\";\r\n  sep.style.justifyContent = \"center\";\r\n  sep.style.top = \"0px\";\r\n  sep.style.left = \"0px\";\r\n\r\n  // sep.style.backgroundColor = \"rgb(255, 0, 0, 0.1)\";\r\n  if (mode === \"horizontal\") {\r\n    sep.style.height = \"100%\";\r\n    sep.style.width = anchor_size;\r\n    sep.style.flexDirection = \"row\";\r\n    sep.style.transform = `translateX(calc(-${anchor_size} / 2))`;\r\n    sep.style.cursor = \"e-resize\";\r\n  } else if (mode === \"vertical\") {\r\n    sep.style.width = \"100%\";\r\n    sep.style.height = anchor_size;\r\n    sep.style.flexDirection = \"column\";\r\n    sep.style.transform = `translateY(calc(-${anchor_size} / 2))`;\r\n    sep.style.cursor = \"n-resize\";\r\n  }\r\n\r\n  const handle = document.createElement(\"div\");\r\n  handle.classList.add(\"sr-separator\");\r\n  if (mode === \"horizontal\") {\r\n    handle.style.height = \"100%\";\r\n  } else if (mode === \"vertical\") {\r\n    handle.style.width = \"100%\";\r\n  }\r\n  sep.append(handle);\r\n  return sep;\r\n}\r\n","import { section } from \"./types\";\r\n\r\nfunction sum(array: Array<number>): number {\r\n  return array.reduce((a, c) => a + c, 0);\r\n}\r\n\r\nfunction arrayLog(title: string, element: Array<number>) {\r\n  console.log(`${title}: ${element.map((e) => `${e}`).join(\", \")}`);\r\n}\r\n\r\nexport function updateSectionSizes(\r\n  sections: Array<section>,\r\n  new_sizes: Array<number | null>,\r\n  container_size: number\r\n): Array<section> {\r\n  // make sure that the new sizes are larger than min sizes\r\n  new_sizes = new_sizes.map((e, i) =>\r\n    e === null ? null : Math.max(sections[i].min_size, e)\r\n  );\r\n  // make sure that the new sizes are smaller than max sizes\r\n  new_sizes = new_sizes.map((e, i) =>\r\n    e === null ? null : Math.min(sections[i].max_size, e)\r\n  );\r\n\r\n  // compute the reference space i.e. the available\r\n  // space to place the sections\r\n  const reference_space: number = Math.max(\r\n    Math.min(container_size, sum(sections.map((e) => e.max_size))),\r\n    sum(sections.map((e) => e.min_size))\r\n  );\r\n\r\n  // at the stage, we know:\r\n  // sum(min_sizes)<=reference_space<=sum(max_sizes)\r\n  // min_size[i] <= new_sizes[i] <= max_size[i]\r\n  // ... except when new_sizes[i] === null (=0)\r\n  // therefore:\r\n  // sum(new_size) <= sum(max_size) but sum(new_size) can be greater than reference_space...\r\n\r\n  // get the indices of unknown new sizes\r\n  // and set unknwon new sizes to minimum sizes\r\n  const unknown_indices = [];\r\n  new_sizes = new_sizes.map((e, i) => {\r\n    if (e === null) {\r\n      unknown_indices.push(i);\r\n      return sections[i].min_size;\r\n    } else {\r\n      return e;\r\n    }\r\n  });\r\n\r\n  if (unknown_indices.length > 0) {\r\n    // if there is unknown new sizes\r\n    let sum_new_sizes = sum(new_sizes);\r\n    if (sum_new_sizes < reference_space) {\r\n      // if the sum of the new sizes below the reference space, we try to grow the unkown sizes as much as possible\r\n      const growth_to_distribute = reference_space - sum_new_sizes;\r\n      const unknown_new_sizes = scaleUpSizes(\r\n        new_sizes.filter((_, i) => unknown_indices.includes(i)),\r\n        sections\r\n          .map((e, i) => e.max_size - new_sizes[i])\r\n          .filter((_, i) => unknown_indices.includes(i)),\r\n        growth_to_distribute\r\n      );\r\n      let k = 0;\r\n      new_sizes = new_sizes.map((e, i) => {\r\n        if (unknown_indices.includes(i)) {\r\n          k++;\r\n          return unknown_new_sizes[k - 1];\r\n        }\r\n        return e;\r\n      });\r\n    } else {\r\n      // if the sum of the new sizes is greater than the reference space, there is nothing to do\r\n      // since the unknown new sizes were set to their minimal values... the scaling down must occuring\r\n      // on the known new sizes\r\n    }\r\n  }\r\n\r\n  // If needed, adjuste the new sizes by scaling down or up\r\n  // the new_sizes while enforcing the min and max sizes specified\r\n  const space_to_adjust = sum(new_sizes) - reference_space;\r\n  if (space_to_adjust > 0) {\r\n    new_sizes = scaleDownSizes(\r\n      new_sizes,\r\n      new_sizes.map((e, i) => e - sections[i].min_size),\r\n      space_to_adjust\r\n    );\r\n  } else if (space_to_adjust < 0) {\r\n    new_sizes = scaleUpSizes(\r\n      new_sizes,\r\n      new_sizes.map((e, i) => sections[i].max_size - e),\r\n      -space_to_adjust\r\n    );\r\n  }\r\n\r\n  // update the sections\r\n  return sections.map((e, i) => ({ ...e, cur_size: new_sizes[i] }));\r\n}\r\n\r\nfunction scaleUpSizes(\r\n  new_sizes: Array<number>,\r\n  max_growth: Array<number>,\r\n  space_to_fill: number\r\n): Array<number> {\r\n  // let's try and grow everything equally\r\n  let avg_growth = space_to_fill / max_growth.length;\r\n  let n_infinite_max = 0;\r\n  let growth = max_growth.map((e) => {\r\n    if (isFinite(e)) {\r\n      return Math.min(avg_growth, e);\r\n    } else {\r\n      n_infinite_max++;\r\n      return avg_growth;\r\n    }\r\n  });\r\n\r\n  let remaining_space_to_fill = space_to_fill - sum(growth);\r\n\r\n  // in case there are some elements with no finite maximum\r\n  // and there is still some space to fill, distribute the\r\n  // remaining space between these elements\r\n  if (n_infinite_max > 0 && remaining_space_to_fill !== 0) {\r\n    avg_growth = remaining_space_to_fill / n_infinite_max;\r\n    growth = growth.map((e, i) => {\r\n      if (isFinite(max_growth[i])) return e;\r\n      return e + avg_growth;\r\n    });\r\n    remaining_space_to_fill = space_to_fill - sum(growth);\r\n  }\r\n\r\n  return new_sizes.map((e, i) => e + growth[i]);\r\n}\r\n\r\nfunction scaleDownSizes(\r\n  new_sizes: Array<number>,\r\n  max_shrink: Array<number>,\r\n  space_to_gain: number\r\n) {\r\n  //max_shrink can be used as weight to distribute space_to_gain\r\n  const sum_max_shrink = sum(max_shrink);\r\n  const spaces_to_remove = max_shrink.map(\r\n    (e) => space_to_gain * (e / sum_max_shrink)\r\n  );\r\n  return new_sizes.map((e, i) => e - spaces_to_remove[i]);\r\n}\r\n","import { section } from \"./types\";\r\n\r\nfunction propagateSectionSizeChange(\r\n  sections: Array<section>,\r\n  change: number,\r\n  backward: boolean\r\n): { remaining: number; sections: Array<section> } {\r\n  if (sections.length === 0) return { remaining: 0, sections };\r\n  // when change > 0, we try to grow the sections\r\n  // when chnage < 0, we try to shrink the sections\r\n  let i: number = backward ? sections.length - 1 : 0;\r\n  while (change != 0 && (backward ? i >= 0 : i < sections.length)) {\r\n    // const max_growth = Number.POSITIVE_INFINITY; // how much it can grow\r\n    const max_growth = sections[i].max_size - sections[i].ini_size; // how much it can grow\r\n    const max_shrink = sections[i].ini_size - sections[i].min_size; // how much it can shrink\r\n    if (change > 0) {\r\n      // growing scenario\r\n      if (change < max_growth) {\r\n        // in case the current element i can absorbe all the growth\r\n        sections[i].cur_size = sections[i].ini_size + change;\r\n        change = 0;\r\n      } else {\r\n        sections[i].cur_size = sections[i].ini_size + max_growth;\r\n        change -= max_growth;\r\n      }\r\n    } else {\r\n      // skrinking scenario\r\n      if (-change < max_shrink) {\r\n        // in case the current element can absorve all the shrinking\r\n        sections[i].cur_size = sections[i].ini_size + change;\r\n        change = 0;\r\n      } else {\r\n        sections[i].cur_size = sections[i].ini_size - max_shrink;\r\n        change += max_shrink;\r\n      }\r\n    }\r\n    i += backward ? -1 : 1;\r\n  }\r\n  return { remaining: change, sections };\r\n}\r\n\r\nexport function updateSectionSizesOnResize(\r\n  sections: Array<section>,\r\n  index: number,\r\n  delta: number\r\n): Array<section> {\r\n  let old_sections = sections.map((e) => ({ ...e, cur_size: e.ini_size }));\r\n  let new_sections = old_sections;\r\n  let remaining = delta;\r\n  let k = 0;\r\n  const max_iteration = 3;\r\n  // console.log(\"-----------------------------------------------\");\r\n  // console.log(\"sections\", sections);\r\n  // console.log(\"old_sections\", old_sections);\r\n\r\n  while (remaining !== 0 && k < max_iteration) {\r\n    // console.log(\"remaining\", remaining);\r\n    // console.log(\"delta\", delta);\r\n    k++;\r\n    // handle the resizing of the elements placed before the separator\r\n    const result_before = propagateSectionSizeChange(\r\n      // old_sections.slice(0, index + 1).reverse(),\r\n      old_sections.slice(0, index + 1),\r\n      delta,\r\n      true\r\n    );\r\n    // console.log(\"result_before\", result_before);\r\n    // handle the resizing of the elements placed after the separator\r\n    const result_after = propagateSectionSizeChange(\r\n      old_sections.slice(index + 1),\r\n      -delta,\r\n      false\r\n    );\r\n    // console.log(\"result_after\", result_after);\r\n    // compute the new sections\r\n    new_sections = [...result_before.sections, ...result_after.sections].map(\r\n      (e) => ({ ...e })\r\n    );\r\n    // check that the change was propagated completly\r\n    remaining =\r\n      Math.abs(result_before.remaining) >= Math.abs(result_after.remaining)\r\n        ? result_before.remaining\r\n        : -result_after.remaining;\r\n\r\n    // update delta\r\n    delta -= remaining;\r\n\r\n    // reset old_sections in case the loop restart\r\n    old_sections = sections.map((e) => ({\r\n      ...e,\r\n      cur_size: e.ini_size,\r\n    }));\r\n  }\r\n  return new_sections;\r\n}\r\n","import { createSeparators } from \"./sep\";\r\nimport {\r\n  configuration,\r\n  resizeItem,\r\n  section,\r\n  sectionConfig,\r\n  sectionsConfig,\r\n  separator,\r\n} from \"./types\";\r\nimport { updateSectionSizes } from \"./sizing\";\r\nimport { updateSectionSizesOnResize } from \"./resizing\";\r\n\r\nexport type { sectionConfig, sectionsConfig } from \"./types\";\r\n// export type sectionsConfig\r\n\r\nconst warn: Function = console.warn;\r\n\r\n/**\r\n * This function makes an HTMLElement a sectionResizer where all its children\r\n * can be resized by dragging separators. Each child can have\r\n * two attributes [data-min] and [data-init] which expect pixels values (with no unit)\r\n * that are used to define its minimum and initial size respectively.\r\n *\r\n * @param container  Container where the children to be resized are\r\n * @param config Main configuration options for the section resizer.\r\n * @returns A sectionResizer object.\r\n */\r\nexport default function sectionResizer(\r\n  container: HTMLElement,\r\n  config: configuration = {\r\n    mode: \"horizontal\",\r\n    resizeMode: \"distributed\",\r\n  }\r\n): {} {\r\n  const default_config: configuration = {\r\n    mode: \"horizontal\",\r\n    resizeMode: \"distributed\",\r\n  };\r\n  config = { ...default_config, ...config };\r\n  const mode = config.mode;\r\n  const resizeMode = config.resizeMode;\r\n\r\n  let x_y: \"x\" | \"y\" = \"x\";\r\n  let w_h: \"width\" | \"height\" = \"width\";\r\n  if (mode === \"vertical\") {\r\n    x_y = \"y\";\r\n    w_h = \"height\";\r\n  } else if (mode !== \"horizontal\") {\r\n    warn(`mode '${mode}' is unknwon. Defaulting to 'horizontal'`);\r\n  }\r\n\r\n  let container_size: number;\r\n\r\n  let initial_container_size: number;\r\n  let sections: Array<section>;\r\n\r\n  let separators: Array<separator>;\r\n\r\n  let resize_observer: ResizeObserver;\r\n  let mutation_observer: MutationObserver;\r\n\r\n  init();\r\n\r\n  function init(): void {\r\n    // store the current container size\r\n    container_size = container.getBoundingClientRect()[w_h];\r\n    initial_container_size = container_size;\r\n\r\n    // set needed style attributes to the container\r\n    const current_position_style = window.getComputedStyle(container).getPropertyValue(\"position\")\r\n    if (![\"absolute\", \"relative\"].includes(current_position_style)) {\r\n        container.style.position = \"relative\";\r\n    }\r\n    container.style.overflow = \"auto\";\r\n    container.style.display = \"grid\";\r\n    //FIXME: I should get rid of these conditions on padding and margin...\r\n    container.style.padding = \"0\";\r\n    container.style.margin = \"0\";\r\n\r\n    // create the event listeners attached to the document element\r\n    // that handle the resizing of the children by dragging the separators\r\n    document.addEventListener(\"pointerdown\", handleResizeStart);\r\n    document.addEventListener(\"pointermove\", handleResizeMove);\r\n    document.addEventListener(\"pointerup\", handleResizeEnd);\r\n\r\n    // retrieve the children\r\n    const children = Array.from(\r\n      container.children as HTMLCollectionOf<HTMLElement>\r\n    );\r\n\r\n    // create the sections\r\n    sections = children.map(buildDefaultSection);\r\n\r\n    // create the separators\r\n    separators = createSeparators(container, children.length, mode);\r\n\r\n    // update the sections sizes\r\n    sections = updateSectionSizes(\r\n      sections,\r\n      sections.map((e) => e.cur_size),\r\n      container_size\r\n    );\r\n    // sections.forEach((s) => (s.ini_size = s.cur_size));\r\n    setInitialSize();\r\n\r\n    // update the grid template\r\n    update();\r\n\r\n    // create a ResizeObserver which is run whenever the container\r\n    // changes sizes (e.g. if the window is resized)\r\n    resize_observer = new ResizeObserver((entries) => {\r\n      const new_container_size: number = container.getBoundingClientRect()[w_h];\r\n      if (new_container_size !== container_size) {\r\n        container_size = new_container_size;\r\n        if (resizeMode !== \"left\" && resizeMode !== \"right\") {\r\n          sections = updateSectionSizes(\r\n            sections,\r\n            sections.map(\r\n              (e) => (e.ini_size / container_size) * new_container_size\r\n            ),\r\n            new_container_size\r\n          );\r\n        } else {\r\n          const change_delta = container_size - initial_container_size;\r\n          if (resizeMode === \"left\") {\r\n            sections = updateSectionSizesOnResize(sections, -1, -change_delta);\r\n          } else if (resizeMode === \"right\") {\r\n            sections = updateSectionSizesOnResize(\r\n              sections,\r\n              sections.length,\r\n              change_delta\r\n            );\r\n          }\r\n        }\r\n      }\r\n      update();\r\n      window.requestAnimationFrame(() => {\r\n        update();\r\n      });\r\n    });\r\n    resize_observer.observe(container);\r\n\r\n    // create a MutationObserver which is run whenever elements are added to\r\n    // the sectionResizer container or removed from it\r\n    mutation_observer = new MutationObserver(() => {\r\n      // stop listening for changes\r\n      mutation_observer.disconnect();\r\n      // remove the existing separators\r\n      separators.forEach((e) => e.element.remove());\r\n      // retrieve the children\r\n      const children = Array.from(\r\n        container.children as HTMLCollectionOf<HTMLElement>\r\n      );\r\n      // re-build sections\r\n      const sections_size_sum =\r\n        sections.reduce((a, c) => a + c.cur_size, 0) / sections.length;\r\n      sections = children.map((e) => {\r\n        const i = sections.findIndex((s) => s.element === e);\r\n        if (i === -1) {\r\n          const default_section = buildDefaultSection(e);\r\n          if (!isNaN(sections_size_sum))\r\n            default_section.cur_size = sections_size_sum;\r\n          return default_section;\r\n        } else {\r\n          return {\r\n            ...sections[i],\r\n          };\r\n        }\r\n      });\r\n\r\n      // create the separators\r\n      separators = createSeparators(container, children.length, mode);\r\n\r\n      // update the sections sizes\r\n      sections = updateSectionSizes(\r\n        sections,\r\n        sections.map((e) => e.cur_size),\r\n        container_size\r\n      );\r\n\r\n      // update the grid template\r\n      update();\r\n\r\n      // re-observe the container for changes\r\n      mutation_observer.observe(container, { childList: true, subtree: false });\r\n    });\r\n    mutation_observer.observe(container, { childList: true, subtree: false });\r\n  }\r\n\r\n  function update() {\r\n    // const container_size = container.getBoundingClientRect()[w_h];\r\n    const gridTemplate = sections\r\n      .map((e) => `${(e.cur_size / container_size) * 100}%`)\r\n      .join(\" \");\r\n    if (mode === \"vertical\") {\r\n      container.style.gridTemplateColumns = \"auto\";\r\n      container.style.gridTemplateRows = gridTemplate;\r\n    } else {\r\n      container.style.gridTemplateRows = \"auto\";\r\n      container.style.gridTemplateColumns = gridTemplate;\r\n    }\r\n    // updateSeparators();\r\n    const position = sections\r\n      .reduce((a, c) => [...a, a[a.length - 1] + c.cur_size], [0])\r\n      .slice(1);\r\n    separators.forEach((s, i) =>\r\n      s.update(`${(position[i] / container_size) * 100}%`)\r\n    );\r\n  }\r\n\r\n  function buildDefaultSection(element: HTMLElement) {\r\n    const min_size =\r\n      \"min\" in element.dataset\r\n        ? Math.max(parseFloat(element.dataset.min), 50)\r\n        : 50;\r\n    const def_size =\r\n      \"init\" in element.dataset\r\n        ? Math.max(min_size, parseFloat(element.dataset.init))\r\n        : null;\r\n    const max_size =\r\n      \"max\" in element.dataset\r\n        ? Math.max(min_size, parseFloat(element.dataset.max))\r\n        : Number.POSITIVE_INFINITY;\r\n    return {\r\n      element: element,\r\n      min_size: min_size,\r\n      max_size: max_size,\r\n      def_size: def_size,\r\n      cur_size: def_size,\r\n      ini_size: def_size,\r\n    };\r\n  }\r\n\r\n  const styleTag = document.createElement(\"style\");\r\n  styleTag.media = \"screen\";\r\n  styleTag.textContent = `* {cursor: ${\r\n    mode === \"vertical\" ? \"n-resize\" : \"e-resize\"\r\n  } !important}`;\r\n\r\n  function setInitialSize() {\r\n    sections = sections.map((e) => ({\r\n      ...e,\r\n      // ini_size: e.element.getBoundingClientRect()[w_h],\r\n      ini_size: e.cur_size,\r\n    }));\r\n    separators = separators.map((e, i) => {\r\n      e.initial_position = e.element.getBoundingClientRect()[x_y];\r\n      return e;\r\n    });\r\n    initial_container_size = container_size;\r\n  }\r\n\r\n  let index: number;\r\n\r\n  function handleResizeStart(event) {\r\n    setInitialSize();\r\n    index = separators.findIndex(\r\n      (s) =>\r\n        s.element === event.target || s.element.children[0] === event.target\r\n    );\r\n    separators.forEach((s) => s.setState(\"silent\"));\r\n    if (index >= 0) {\r\n      event.preventDefault();\r\n      separators[index].setState(\"resizing\");\r\n      separators[index].setHighlight(true);\r\n      document.head.appendChild(styleTag);\r\n    }\r\n  }\r\n  function handleResizeMove(event) {\r\n    if (index >= 0) {\r\n      const mouse_position = event[x_y];\r\n      const change_delta =\r\n        mouse_position - (separators[index].initial_position + 10);\r\n      sections = updateSectionSizesOnResize(sections, index, change_delta);\r\n      update();\r\n    }\r\n  }\r\n  function handleResizeEnd() {\r\n    if (index >= 0) {\r\n      setInitialSize();\r\n      separators[index].setHighlight(false);\r\n      index = -1;\r\n      styleTag.remove();\r\n    }\r\n    separators.forEach((s) => s.setState(\"idle\"));\r\n  }\r\n\r\n  function requestAnimationFramePromise(): Promise<void> {\r\n    return new Promise((resolve) => {\r\n      requestAnimationFrame(() => {\r\n        resolve();\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Configure min and/or max sizes of all sections, or specific sections\r\n   *\r\n   * @param {object[]} config - configuration object\r\n   * @returns A promise that resolve at the next animation frame.\r\n   */\r\n  function configure(\r\n    config: Array<sectionConfig> | sectionsConfig\r\n  ): Promise<void> {\r\n    if (!Array.isArray(config)) {\r\n      config = sections.map((_, index) => ({\r\n        index,\r\n        ...config,\r\n      }));\r\n    }\r\n    config.forEach((e) => {\r\n      if (e.index !== undefined && e.index >= 0 && e.index < sections.length) {\r\n        if (e.min) sections[e.index].min_size = Math.max(50, e.min); // I enforce 50px as a minimum size to prevent weird behavior with scrollbars and overlapping separators\r\n        if (e.max) sections[e.index].max_size = Math.max(0, e.max);\r\n      }\r\n    });\r\n    sections = updateSectionSizes(\r\n      sections,\r\n      sections.map((e) => e.cur_size),\r\n      container_size\r\n    );\r\n    update();\r\n    setInitialSize();\r\n    return requestAnimationFramePromise();\r\n  }\r\n  function resize(config: Array<resizeItem>): Promise<void> {\r\n    // requestAnimationFrame(() => {\r\n    const new_sizes = sections.map((e) => null);\r\n    config.forEach((e) => {\r\n      if (\r\n        e.index !== undefined &&\r\n        e.index >= 0 &&\r\n        e.index < sections.length &&\r\n        e.size !== undefined\r\n      ) {\r\n        new_sizes[e.index] = e.size;\r\n      }\r\n    });\r\n    console.log(\"new_sizes\", new_sizes);\r\n    sections = updateSectionSizes(sections, new_sizes, container_size);\r\n    update();\r\n    setInitialSize();\r\n    // });\r\n\r\n    return requestAnimationFramePromise();\r\n  }\r\n  function getSections(): Array<section> {\r\n    return sections;\r\n  }\r\n  return {\r\n    configure,\r\n    resize,\r\n    getSections,\r\n  };\r\n}\r\n"],"names":["createSeparators","parent","n_children","mode","separators","Array","fill","map","_","element","anchor_size","sep","document","createElement","classList","add","style","position","display","justifyContent","top","left","height","width","flexDirection","transform","cursor","handle","append","createSep","onHighlightCallbacks","Set","state","setHighlight","yes","forEach","c","children","toggle","addEventListener","initial_position","update","loc","setState","new_state","on","event","callback","off","clear","delete","e","sum","array","reduce","a","updateSectionSizes","sections","new_sizes","container_size","i","Math","max","min_size","min","max_size","reference_space","unknown_indices","push","length","sum_new_sizes","growth_to_distribute","unknown_new_sizes","scaleUpSizes","filter","includes","k","space_to_adjust","max_shrink","space_to_gain","sum_max_shrink","spaces_to_remove","scaleDownSizes","cur_size","max_growth","space_to_fill","avg_growth","n_infinite_max","growth","isFinite","remaining_space_to_fill","propagateSectionSizeChange","change","backward","remaining","ini_size","updateSectionSizesOnResize","index","delta","old_sections","Object","assign","new_sections","result_before","slice","result_after","abs","warn","console","sectionResizer","container","config","resizeMode","initial_container_size","resize_observer","mutation_observer","x_y","w_h","gridTemplate","join","gridTemplateColumns","gridTemplateRows","s","buildDefaultSection","dataset","parseFloat","def_size","init","Number","POSITIVE_INFINITY","getBoundingClientRect","current_position_style","window","getComputedStyle","getPropertyValue","overflow","padding","margin","handleResizeStart","handleResizeMove","handleResizeEnd","from","setInitialSize","ResizeObserver","entries","new_container_size","change_delta","requestAnimationFrame","observe","MutationObserver","disconnect","remove","sections_size_sum","findIndex","default_section","isNaN","childList","subtree","styleTag","target","preventDefault","head","appendChild","requestAnimationFramePromise","Promise","resolve","media","textContent","configure","isArray","undefined","resize","size","getSections"],"mappings":"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"}